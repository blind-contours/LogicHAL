RuleAndAnd <- precomputed_scores$RuleAndAnd
RuleAndOr <- precomputed_scores$RuleAndOr
RuleOrAnd <- precomputed_scores$RuleOrAnd
RuleOrOr <- precomputed_scores$RuleOrOr
# Initialize list to store subtrees
subtrees <- list()
# Function to create a subtree
create_subtree <- function(F1_score, rule, type) {
if (any(F1_score != 0, na.rm = TRUE)) {
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
if (best_root_f1 >= parent_f1) {
# cat("Depth:", current_depth, "- Best rule:", root_rule_desc, "with F1 score:", best_root_f1, " - Type:", type, "\n")
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
# Recursive call for the subtree
subtree_result <- build_logic_tree(data = data, outcome = outcome, columns = columns,
max_depth = max_depth, current_depth = current_depth + 1,
parent_f1 = best_root_f1, previous_rule = root_rule,
previous_rule_name = root_rule_desc, best_info_env = best_info_env)
return(list(
split = root_rule_desc,
f1 = round(best_root_f1, 3),
subtree = subtree_result$tree
))
}
}
return(NULL)
}
# Create subtrees for each type
subtrees$indiv_ruleAnd <- create_subtree(F1_score = F1_indiv_ruleAnd, rule = Rule_indiv_And, type = "indiv_ruleAnd")
subtrees$indiv_ruleOr <- create_subtree(F1_indiv_ruleOr, Rule_indiv_Or, "indiv_ruleOr")
F1_score = F1_Or
rule = RuleOr
type = "Or"
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
root_rule_desc
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
if (best_root_f1 >= parent_f1) {
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
# Recursive call for the subtree
subtree_result <- build_logic_tree(data = data, outcome = outcome, columns = columns,
max_depth = max_depth, current_depth = current_depth + 1,
parent_f1 = best_root_f1, previous_rule = root_rule,
previous_rule_name = root_rule_desc, best_info_env = best_info_env)
return(list(
split = root_rule_desc,
f1 = round(best_root_f1, 3),
subtree = subtree_result$tree
))
}
best_info_env$best_rule_path
root_rule_desc
parent_f1
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
best_info_env$best_rule_path
root_rule_desc
c(best_info_env$best_rule_path, root_rule_desc)
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
current_complexity
new_complexity
root_rule_desc
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
best_root_f1 >= parent_f1
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
best_info_env$best_rule_path
current_complexity
best_root_f1
parent_f1
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
best_info_env$best_rule_path
best_root_f1 > best_info_env$best_f1
best_root_f1 == best_info_env$best_f1
best_info_env$best_f1
best_info_env$best_f1 <- 0
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
# Recursive call for the subtree
subtree_result <- build_logic_tree(data = data, outcome = outcome, columns = columns,
max_depth = max_depth, current_depth = current_depth + 1,
parent_f1 = best_root_f1, previous_rule = root_rule,
previous_rule_name = root_rule_desc, best_info_env = best_info_env)
best_info_env$best_rule_path
best_info_env$best_f1
best_info_env$best_f1 <- 0
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
best_info_env$best_rule_path
best_info_env$best_f1
current_depth = current_depth + 1
parent_f1 = best_root_f1
previous_rule = root_rule
previous_rule_name = root_rule_desc
best_info_env = best_info_env
# Base case: max depth reached or no data
if (current_depth > max_depth || nrow(data) == 0) {
return(list(best_f1 = best_info_env$best_f1, best_rule_path = best_info_env$best_rule_path, subtrees = NULL))
}
is_binary <- length(unique(data[[outcome]])) == 2
if (is_binary) {
precomputed_scores <- computeF1ScoresWithLogic(data, columns, data[[outcome]], previous_rule, previous_rule_name)
} else {
precomputed_scores <- computeMeanDifferenceScoresWithLogic(data, columns, data[[outcome]], previous_rule, previous_rule_name)
}
# Extract results
F1_indiv_ruleAnd <- precomputed_scores$F1_indiv_ruleAnd
F1_indiv_ruleOr <- precomputed_scores$F1_indiv_ruleOr
F1_And <- precomputed_scores$F1And
F1_Or <- precomputed_scores$F1Or
F1AndAnd <- precomputed_scores$F1AndAnd
F1AndOr <- precomputed_scores$F1AndOr
F1OrAnd <- precomputed_scores$F1OrAnd
F1OrOr <- precomputed_scores$F1OrOr
Rule_indiv_And <- precomputed_scores$Rule_indiv_And
Rule_indiv_Or <- precomputed_scores$Rule_indiv_Or
RuleAnd <- precomputed_scores$RuleAnd
RuleOr <- precomputed_scores$RuleOr
RuleAndAnd <- precomputed_scores$RuleAndAnd
RuleAndOr <- precomputed_scores$RuleAndOr
RuleOrAnd <- precomputed_scores$RuleOrAnd
RuleOrOr <- precomputed_scores$RuleOrOr
RuleOrOr
F1OrOr
Rule_indiv_And <- precomputed_scores$Rule_indiv_And
Rule_indiv_Or <- precomputed_scores$Rule_indiv_Or
RuleAnd <- precomputed_scores$RuleAnd
RuleOr <- precomputed_scores$RuleOr
RuleAndAnd <- precomputed_scores$RuleAndAnd
RuleAndOr <- precomputed_scores$RuleAndOr
RuleOrAnd <- precomputed_scores$RuleOrAnd
RuleOrOr <- precomputed_scores$RuleOrOr
# Initialize list to store subtrees
subtrees <- list()
# Function to create a subtree
create_subtree <- function(F1_score, rule, type) {
if (any(F1_score != 0, na.rm = TRUE)) {
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
if (best_root_f1 >= parent_f1) {
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
# Recursive call for the subtree
subtree_result <- build_logic_tree(data = data, outcome = outcome, columns = columns,
max_depth = max_depth, current_depth = current_depth + 1,
parent_f1 = best_root_f1, previous_rule = root_rule,
previous_rule_name = root_rule_desc, best_info_env = best_info_env)
return(list(
split = root_rule_desc,
f1 = round(best_root_f1, 3),
subtree = subtree_result$tree
))
}
}
return(NULL)
}
F1_score = F1_indiv_ruleAnd
rule = Rule_indiv_And
type = "indiv_ruleAnd"
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
root_rule_desc
best_root_f1 >= parent_f1
parent_f1
best_root_f1
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
best_root_f1
best_info_env$best_f1
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
best_info_env$best_rule_path
current_depth = current_depth + 1
best_root_f1
parent_f1 = best_root_f1
previous_rule = root_rule
previous_rule_name = root_rule_desc
root_rule_desc
best_info_env = best_info_env
current_depth
# Base case: max depth reached or no data
if (current_depth > max_depth || nrow(data) == 0) {
return(list(best_f1 = best_info_env$best_f1, best_rule_path = best_info_env$best_rule_path, subtrees = NULL))
}
is_binary <- length(unique(data[[outcome]])) == 2
if (is_binary) {
precomputed_scores <- computeF1ScoresWithLogic(data, columns, data[[outcome]], previous_rule, previous_rule_name)
} else {
precomputed_scores <- computeMeanDifferenceScoresWithLogic(data, columns, data[[outcome]], previous_rule, previous_rule_name)
}
# Extract results
F1_indiv_ruleAnd <- precomputed_scores$F1_indiv_ruleAnd
F1_indiv_ruleOr <- precomputed_scores$F1_indiv_ruleOr
F1_And <- precomputed_scores$F1And
F1_Or <- precomputed_scores$F1Or
F1AndAnd <- precomputed_scores$F1AndAnd
F1AndOr <- precomputed_scores$F1AndOr
F1OrAnd <- precomputed_scores$F1OrAnd
F1OrOr <- precomputed_scores$F1OrOr
Rule_indiv_And <- precomputed_scores$Rule_indiv_And
Rule_indiv_Or <- precomputed_scores$Rule_indiv_Or
RuleAnd <- precomputed_scores$RuleAnd
RuleOr <- precomputed_scores$RuleOr
RuleAndAnd <- precomputed_scores$RuleAndAnd
RuleAndOr <- precomputed_scores$RuleAndOr
RuleOrAnd <- precomputed_scores$RuleOrAnd
RuleOrOr <- precomputed_scores$RuleOrOr
# Initialize list to store subtrees
subtrees <- list()
# Function to create a subtree
create_subtree <- function(F1_score, rule, type) {
if (any(F1_score != 0, na.rm = TRUE)) {
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
if (best_root_f1 >= parent_f1) {
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
# Recursive call for the subtree
subtree_result <- build_logic_tree(data = data, outcome = outcome, columns = columns,
max_depth = max_depth, current_depth = current_depth + 1,
parent_f1 = best_root_f1, previous_rule = root_rule,
previous_rule_name = root_rule_desc, best_info_env = best_info_env)
return(list(
split = root_rule_desc,
f1 = round(best_root_f1, 3),
subtree = subtree_result$tree
))
}
}
return(NULL)
}
F1_score = F1_indiv_ruleAnd
rule = Rule_indiv_And
type = "indiv_ruleAnd"
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
best_root_f1
root_rule_desc
best_root_f1 >= parent_f1
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
best_root_f1 > best_info_env$best_f1
best_root_f1 == best_info_env$best_f1
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
new_complexity < current_complexity
best_info_env$best_rule_path
new_complexity < current_complexity
new_complexity == current_complexity
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexitynew_complexity < current_complexity) {
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else if (new_complexity == current_complexity) {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
best_info_env$best_rule_path
# Function to create a subtree
create_subtree <- function(F1_score, rule, type) {
if (any(F1_score != 0, na.rm = TRUE)) {
max_f1_index <- which.max(F1_score)
best_root_f1 <- F1_score[max_f1_index]
root_rule_desc <- rule[max_f1_index]
if (best_root_f1 >= parent_f1) {
# Evaluate the root rule using dplyr
root_rule <- data %>%
mutate(rule = eval(parse(text = root_rule_desc))) %>%
pull(rule)
# Update the best F1 and best rule path if this is the best so far
if (best_root_f1 > best_info_env$best_f1) {
best_info_env$best_f1 <- best_root_f1
best_info_env$best_rule_path <- root_rule_desc
} else if (best_root_f1 == best_info_env$best_f1) {
# Tie-breaking logic: prioritize rules with fewer logical operators
current_complexity <- count_logical_operators(best_info_env$best_rule_path)
new_complexity <- count_logical_operators(root_rule_desc)
if (new_complexity < current_complexity) {
best_info_env$best_rule_path <- root_rule_desc
} else if (new_complexity == current_complexity) {
best_info_env$best_rule_path <- c(best_info_env$best_rule_path, root_rule_desc)
}
}
# Recursive call for the subtree
subtree_result <- build_logic_tree(data = data, outcome = outcome, columns = columns,
max_depth = max_depth, current_depth = current_depth + 1,
parent_f1 = best_root_f1, previous_rule = root_rule,
previous_rule_name = root_rule_desc, best_info_env = best_info_env)
return(list(
split = root_rule_desc,
f1 = round(best_root_f1, 3),
subtree = subtree_result$tree
))
}
}
return(NULL)
}
# Create subtrees for each type
subtrees$indiv_ruleAnd <- create_subtree(F1_score = F1_indiv_ruleAnd, rule = Rule_indiv_And, type = "indiv_ruleAnd")
best_info_env$best_rule_path
best_info_env$best_f1
load_all()
result <- build_logic_tree(data = current_data, outcome = outcome, columns = remaining_columns, max_depth = max_depth, best_info_env = best_info_env)
result$best_rule_path
# Build next best tree
best_info_env <- new.env()
best_info_env$best_f1 <- 0
best_info_env$best_rule_path <- list()
result <- build_logic_tree(data = current_data, outcome = outcome, columns = remaining_columns, max_depth = max_depth, best_info_env = best_info_env)
result$best_rule_path
# Run LogicHAL
result <- LogicHAL(data = df, outcome = "outcome", columns = colnames(X), max_trees = 2, max_depth = 3)
# Print final model and trees used
coef(result$model)
